<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Syst√®me Solaire 3D & Voie Lact√©e</title>
    <style>
        html,body{width:100%;height:100%;margin:0;padding:0;overflow:hidden;background:#020205;font-family:sans-serif;color:#fff;touch-action:none;color-scheme:dark}
        #ui-container{position:absolute;top:10px;left:10px;background:rgba(10,15,30,.85);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);z-index:10;backdrop-filter:blur(4px);max-width:240px;max-height:85vh;overflow-y:auto}
        h1{margin:0 0 10px;font-size:1rem;color:#4da8da;text-transform:uppercase}
        .control-group{margin-bottom:10px;display:flex;flex-direction:column;gap:5px}
        .checkbox-group{flex-direction:row;align-items:center;cursor:pointer;font-size:.9rem}
        .btn-group{display:flex;gap:5px}
        input[type=range]{width:100%;cursor:pointer}
        input[type=date], select{background:#1a2535;color:#ffffff;border:1px solid rgba(77,168,218,0.5);padding:5px;border-radius:5px;font-family:inherit;width:100%;outline:none;cursor:pointer;color-scheme:dark;}
        button{background:#4da8da;color:#050510;border:none;padding:6px;border-radius:5px;cursor:pointer;font-weight:bold;flex:1; transition: 0.3s;}
        button:hover{background:#79c2ea}
        #toggle-ui-btn{background:#3a4a5a;color:#fff;margin-top:5px;width:100%}
        
        #galaxy-btn{background: linear-gradient(45deg, #2a0845, #6441A5); color:#fff; margin-bottom:10px; width:100%; border: 1px solid #8b4dda; box-shadow: 0 0 10px rgba(100,65,165,0.5);}
        #galaxy-btn:hover { background: linear-gradient(45deg, #6441A5, #8b4dda); box-shadow: 0 0 15px rgba(139,77,218,0.8); }
        
        #night-mode-btn{background:#882222;color:#fff;border:1px solid #ff4444; width: 100%;}
        
        #tooltip{position:absolute;background:rgba(0,0,0,.9);border:1px solid #4da8da;padding:10px;border-radius:8px;pointer-events:none;opacity:0;z-index:20;transition: opacity 0.1s;}
        #tooltip .value{color:#4da8da;font-weight:bold}
        #red-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,.7);mix-blend-mode:multiply;pointer-events:none;z-index:9998}

        #info-panel {
            position: absolute; bottom: -100%; left: 50%; transform: translateX(-50%);
            background: rgba(10, 15, 30, 0.92); padding: 20px;
            border-radius: 15px 15px 0 0; border: 1px solid rgba(77,168,218,0.4); border-bottom: none;
            z-index: 15; backdrop-filter: blur(8px); color: white; width: 90%; max-width: 450px;
            transition: bottom 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); text-align: center;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }
        #info-panel.active { bottom: 0; }
        #info-panel h2 { margin: 0 0 15px 0; font-size: 1.4rem; letter-spacing: 1px; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem; text-align: left;}
        .info-grid div { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .info-grid span { color: #4da8da; font-weight: bold; display: block; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 3px;}
        #close-info { position: absolute; top: 15px; right: 20px; cursor: pointer; color: #888; font-weight: bold; font-size: 1.2rem; transition: 0.2s; }
        #close-info:hover { color: white; transform: scale(1.1); }
        
        /* Correctif Android : Force le calendrier en mode clair (texte noir sur fond blanc) pour garantir la lisibilit√© */
        body.is-android input[type=date] { color-scheme: light; background: #f0f0f0; color: #000000; border-color: #ccc; }
        canvas{display:block;width:100%;height:100%}
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="ui-content">
            <h1>Exploration 3D</h1>
            <button id="galaxy-btn">üåå R√©v√©ler la Galaxie</button>

            <div id="solar-controls">
                <div class="control-group">
                    <label style="font-size: 0.9rem;">üéØ Chercher un astre :</label>
                    <select id="target-select"><option value="-1">Vue libre</option></select>
                </div>
                <div class="control-group">
                    <label style="font-size: 0.9rem;">üóìÔ∏è Date : <span id="date-display" style="color:#4da8da;font-weight:bold;"></span></label>
                    <input type="date" id="date-picker">
                </div>
                <div class="control-group">
                    <label style="font-size: 0.9rem;">Vitesse : <span id="speed-display">1 jour/sec</span></label>
                    <input type="range" id="speed-slider" min="-10" max="10" step="0.5" value="1">
                </div>
                <div class="control-group">
                    <div class="btn-group">
                        <button id="zoom-in-btn">üîç +</button>
                        <button id="zoom-out-btn">üîç -</button>
                    </div>
                </div>
                <div class="control-group">
                    <div class="btn-group">
                        <button id="pause-btn">Mettre en pause</button>
                    </div>
                    <button id="night-mode-btn" style="margin-top: 5px;">üî¥ Nuit</button>
                </div>
                <div class="control-group checkbox-group"><input type="checkbox" id="toggle-ecliptic"><label for="toggle-ecliptic">Grille √âcliptique</label></div>
                <div class="control-group checkbox-group"><input type="checkbox" id="toggle-orbits" checked><label for="toggle-orbits">Orbites</label></div>
                <div class="control-group checkbox-group"><input type="checkbox" id="toggle-asteroids" checked><label for="toggle-asteroids">Ceinture principale</label></div>
                <div class="control-group checkbox-group"><input type="checkbox" id="toggle-kuiper" checked><label for="toggle-kuiper">Ceinture de Kuiper</label></div>
                <div class="control-group checkbox-group"><input type="checkbox" id="toggle-constellations"><label for="toggle-constellations">Constellations (Orion...)</label></div>
            </div>
            <a href="index.html" style="text-decoration:none;"><button id="home-btn" style="background:#3a4a5a; color:#fff; margin-top:10px; width:100%">üè† Accueil</button></a>
            <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 8px;">Version 1.1 (28/02/2026)</div>
        </div>
        <button id="toggle-ui-btn">üëÅÔ∏è Masquer l'interface</button>
    </div>

    <div id="info-panel">
        <div id="close-info">‚úï</div>
        <h2 id="info-name">Plan√®te</h2>
        <div class="info-grid">
            <div><span>Cat√©gorie</span><div id="info-type" style="color:#ddd;">-</div></div>
            <div><span>Diam√®tre</span><div id="info-diam" style="color:#ddd;">-</div></div>
            <div><span>Masse</span><div id="info-mass" style="color:#ddd;">-</div></div>
            <div><span>Temp√©rature</span><div id="info-temp" style="color:#ddd;">-</div></div>
        </div>
    </div>

    <div id="red-overlay"></div>

    <div id="tooltip">
        <h2 id="tt-name" style="margin:0 0 5px 0; font-size:1.1rem;">Plan√®te</h2>
        <p style="margin:2px 0; font-size:0.85rem;" id="tt-line1">Dist : <span id="tt-dist" class="value">-</span></p>
        <p style="margin:2px 0; font-size:0.85rem;" id="tt-line2">Excentr : <span id="tt-ecc" class="value">-</span></p>
        <p style="margin:6px 0 0 0; font-size:0.9rem; padding-top:4px; border-top:1px solid rgba(255,255,255,0.2);" id="tt-line-horizon"></p>
        <p style="margin:4px 0 0 0; font-size:0.9rem;" id="tt-line3"></p>
    </div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { J2000, getOrbitalPosition, PLANETS_DATA } from './astro-logic.js';

        // D√©tection automatique : Si on est sur Android, on ajoute une classe pour adapter le CSS
        if (/Android/i.test(navigator.userAgent)) {
            document.body.classList.add('is-android');
        }

        const scene = new THREE.Scene();
        // Modification majeure : La cam√©ra peut voir jusqu'√† 150 000 unit√©s de distance !
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 150000);
        camera.position.set(0, 900, 1800); // Recul de la cam√©ra pour inclure Jupiter/Saturn dans le champ initial
        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true }); // logarithmicDepthBuffer emp√™che le clipping
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace; 
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 60000; // Permet de reculer √©norm√©ment pour voir la galaxie enti√®re

        scene.add(new THREE.PointLight(0xffffff, 1800, 0, 0)); // √âclairage plus doux
        scene.add(new THREE.AmbientLight(0xffffff, 0.7)); // Ombres moins "opaques" (plus d√©bouch√©es)

        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous'); 
        
        function loadTextureSafely(url, material) {
            textureLoader.load(url, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                material.map = texture;
                material.color.setHex(0xffffff); 
                material.needsUpdate = true;
            });
        }
        const CDN_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/';
        
        // --- NOUVEAU : LA GALAXIE √Ä L'√âCHELLE ---
        const galaxyGroup = new THREE.Group();
        // Position du Centre Galactique (Tr√®s loin de nous)
        const GALAXY_CENTER = new THREE.Vector3(16355, -2000, -12218);
        galaxyGroup.position.copy(GALAXY_CENTER);
        // L√©g√®re inclinaison pour un angle de vue spectaculaire
        galaxyGroup.rotation.x = 0.15;
        galaxyGroup.rotation.z = -0.1;
        scene.add(galaxyGroup);

        // 1. Les Bras Spiraux (50 000 √©toiles)
        const galaxyGeo = new THREE.BufferGeometry();
        const galaxyPos = [];
        const galaxyColors = [];
        const colorCore = new THREE.Color(0xffeebb); // C≈ìur hyper lumineux
        const colorArm = new THREE.Color(0x3377ff);  // Bras bleus d'√©toiles jeunes

        const numStars = 50000;
        const galaxyRadius = 35000;
        const arms = 4;
        const spin = 7.0; // Plus de torsion pour correspondre √† la structure r√©elle et √† la 2D

        for (let i = 0; i < numStars; i++) {
            // Plus d'√©toiles vers le centre
            const r = Math.pow(Math.random(), 1.5) * galaxyRadius; 
            const branchAngle = (Math.floor(Math.random() * arms) / arms) * Math.PI * 2;
            const spinAngle = r * (spin / galaxyRadius);
            
            // Dispersion : le centre est dense, les bras sont flous
            const scatter = (Math.random() - 0.5) * (galaxyRadius - r) * 0.15;
            const angle = branchAngle + spinAngle + scatter/r;
            
            // √âpaisseur de la galaxie
            const thickness = Math.max(200, 4000 - r) * 0.5;
            const y = (Math.random() - 0.5) * thickness * (Math.random() > 0.5 ? 1 : -1) * Math.random();

            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            galaxyPos.push(x, y, z);
            
            // Couleur d√©grad√©e du centre vers l'ext√©rieur
            const mixedColor = colorCore.clone().lerp(colorArm, r / galaxyRadius + Math.random()*0.2);
            galaxyColors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }
        
        galaxyGeo.setAttribute('position', new THREE.Float32BufferAttribute(galaxyPos, 3));
        galaxyGeo.setAttribute('color', new THREE.Float32BufferAttribute(galaxyColors, 3));
        
        const galaxyMat = new THREE.PointsMaterial({ 
            size: 40, sizeAttenuation: true, vertexColors: true, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
        });
        galaxyMat.userData = { baseOpacity: 0.8 }; // M√©moire pour la transition
        galaxyGroup.add(new THREE.Points(galaxyGeo, galaxyMat));

        // 2. Le Noyau Central (Sagittarius A*)
        const coreMesh = new THREE.Mesh(
            new THREE.SphereGeometry(2000, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffcc88, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false })
        );
        coreMesh.userData = { baseOpacity: 0.5 };
        galaxyGroup.add(coreMesh);

        // 3. Cr√©ation des √©tiquettes g√©antes
        function createGiantLabel(text, color, scaleSize) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d'); ctx.font = 'bold 36px Arial'; ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.fillText(text, 256, 64);
            const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false, transparent: true, opacity: 0 });
            mat.userData = { baseOpacity: 1 };
            const sprite = new THREE.Sprite(mat); sprite.scale.set(scaleSize, scaleSize/4, 1);
            return sprite;
        }

        const coreLabel = createGiantLabel("Centre Galactique", "#ffddaa", 4000);
        coreLabel.position.set(0, 3000, 0);
        galaxyGroup.add(coreLabel);

        // √âtiquette au niveau du syst√®me solaire, invers√©e par rapport au centre de la galaxie
        const orionLabel = createGiantLabel("üìç Bras d'Orion (Notre position)", "#aaddff", 3000);
        orionLabel.position.copy(GALAXY_CENTER).multiplyScalar(-1); // Ram√®ne l'√©tiquette au niveau de (0,0,0) global
        orionLabel.position.y += 1000;
        galaxyGroup.add(orionLabel);

        // --- AJOUT DU FOND √âTOIL√â (Comme en 2D) ---
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 5000; i++) {
            const r = 90000; // Rayon tr√®s large pour entourer tout le syst√®me et la galaxie
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: false, transparent: true, opacity: 0.6 });
        scene.add(new THREE.Points(starGeometry, starMaterial));

        // --- GRILLE √âCLIPTIQUE ---
        const eclipticGrid = new THREE.GridHelper(3000, 20, 0x4da8da, 0x1a2535);
        eclipticGrid.material.opacity = 0.2;
        eclipticGrid.material.transparent = true;
        eclipticGrid.visible = false;
        scene.add(eclipticGrid);


        // --- MATH√âMATIQUES SYST√àME SOLAIRE ---
        // Correction pour la pr√©cision : Toujours travailler en UTC. On initialise √† la date du jour √† midi UTC.
        const today = new Date();
        let simulatedDate = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 12, 0, 0));
        const obsLat = 50.53 * Math.PI / 180; 
        const obsLon = 4.60; 
        
        const scale = 1.5; 
        const planets = PLANETS_DATA.map(p => ({
            ...p,
            a: p.a * scale,
            history: [],
            moons: p.moons ? p.moons.map(m => ({ ...m, dist: m.dist * scale, history: [] })) : null
        }));

        const astresMeshes = [];
        const cliquables = [];
        const orbitesMeshes = [];

        const sunCanv = document.createElement('canvas'); sunCanv.width=256; sunCanv.height=256;
        const sCtx = sunCanv.getContext('2d');
        const grd = sCtx.createRadialGradient(128,128,0,128,128,128);
        grd.addColorStop(0,'#ffffff'); grd.addColorStop(0.2,'#fff200'); grd.addColorStop(1,'#ff3300');
        sCtx.fillStyle=grd; sCtx.fillRect(0,0,256,256);
        const sunTex = new THREE.CanvasTexture(sunCanv);

        // --- MOTEUR KEPLERIEN (PR√âCISION GARANTIE) ---
        // R√©solution de M = E - e sin E par m√©thode de Newton-Raphson
        function solveKepler(M, e) {
            let E = M;
            for (let i = 0; i < 5; i++) {
                E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
            }
            return E;
        }

        // Calcul de la position 3D exacte selon les √©l√©ments orbitaux
        function getKeplerPosition(a, e, period, baseAngle, omega, days, iDeg, nodeDeg) {
            const n = (2 * Math.PI) / period;
            let M = baseAngle + n * days;
            const E = solveKepler(M, e);
            
            // Coordonn√©es dans le plan orbital (P pointe vers le p√©rih√©lie)
            const P = a * (Math.cos(E) - e);
            const Q = a * Math.sqrt(1 - e * e) * Math.sin(E);
            
            // Conversion des angles en radians
            const w = (omega || 0) * Math.PI / 180;
            const iRad = (iDeg || 0) * Math.PI / 180;
            const node = (nodeDeg || 0) * Math.PI / 180;
            
            // 1. Rotation dans le plan (Argument du p√©rih√©lie)
            const x1 = P * Math.cos(w) - Q * Math.sin(w);
            const y1 = P * Math.sin(w) + Q * Math.cos(w);
            
            // 2. Inclinaison par rapport √† l'√©cliptique
            const x2 = x1;
            const y2 = y1 * Math.cos(iRad);
            const z2 = y1 * Math.sin(iRad); // Hauteur par rapport au plan (Z astronomique)
            
            // 3. Orientation du plan (Longitude du n≈ìud ascendant)
            const x3 = x2 * Math.cos(node) - y2 * Math.sin(node);
            const y3 = x2 * Math.sin(node) + y2 * Math.cos(node);
            
            return { x: x3, y: y3, z: z2 };
        }

        function createPlanetLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 32px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 3;
            ctx.fillText(text, 128, 42);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(40, 10, 1);
            return sprite;
        }

        planets.forEach((p, i) => {
            const group = new THREE.Group(); scene.add(group);
            const material = (i === 0) ? new THREE.MeshBasicMaterial({ map: sunTex }) : new THREE.MeshStandardMaterial({ color: new THREE.Color(p.color) });
            
            if (p.tex) loadTextureSafely(CDN_URL + p.tex, material);

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.radius, 32, 32), material);
            mesh.userData = { id: i, isMoon: false, ref: p };
            group.add(mesh); cliquables.push(mesh);
            p.meshRef = mesh; p.groupRef = group;

            const label = createPlanetLabel(p.name);
            label.position.y = p.radius + (p.name === "Soleil" ? 50 : 8);
            if (p.name === "Soleil") label.scale.set(100, 25, 1);
            group.add(label);

            // Initialisation des tra√Æn√©es (trails) pour les plan√®tes
            if (i > 0) {
                p.trailGeometry = new THREE.BufferGeometry();
                p.trailMesh = new THREE.Line(p.trailGeometry, new THREE.LineBasicMaterial({ color: new THREE.Color(p.color), transparent: true, opacity: 0.5 }));
                scene.add(p.trailMesh);
            }

            if (p.name === "Saturne") {
                const ring = new THREE.Mesh(new THREE.RingGeometry(18, 28, 64), new THREE.MeshStandardMaterial({ color: 0xaa9977, side: THREE.DoubleSide, transparent: true, opacity: 0.8 }));
                ring.rotation.x = Math.PI / 2; mesh.add(ring);
            }

            if (i > 0) {
                const pts = [];
                for(let j=0; j<=128; j++) {
                    const pos = getKeplerPosition(p.a, p.e, p.period, p.baseAngle, p.omega, (j/128)*Math.abs(p.period), p.i, p.node);
                    pts.push(new THREE.Vector3(pos.x, pos.z, pos.y));
                }
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color: p.color, transparent: true, opacity: 0.4 }));
                scene.add(line); orbitesMeshes.push(line);
            }

            if (p.moons) {
                p.moons.forEach((m, j) => {
                    const mMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(m.color) });
                    if (m.tex) loadTextureSafely(CDN_URL + m.tex, mMat);
                    const mMesh = new THREE.Mesh(new THREE.SphereGeometry(m.radius, 32, 32), mMat);
                    mMesh.userData = { id: i, moonId: j, isMoon: true, ref: m };
                    group.add(mMesh); cliquables.push(mMesh);
                    m.meshRef = mMesh;
                    
                    const mOrbit = new THREE.Line(new THREE.BufferGeometry().setFromPoints(Array.from({length:65}, (_,k)=>new THREE.Vector3(Math.cos(k/64*Math.PI*2)*m.dist,0,Math.sin(k/64*Math.PI*2)*m.dist))), new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.3}));
                    group.add(mOrbit); orbitesMeshes.push(mOrbit);
                });
            }
        });

        const asteroidBelt = new THREE.Group(); scene.add(asteroidBelt);
        const kuiperBelt = new THREE.Group(); scene.add(kuiperBelt);

        const createBeltPoints = (count, aMin, aVar, eMin, eVar, size, colorHex, opacity) => {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for (let i = 0; i < count; i++) {
                const a = (aMin + Math.random() * aVar) * scale;
                const e = eMin + Math.random() * eVar;
                const angle = Math.random() * Math.PI * 2;
                
                const c = a * e, b = a * Math.sqrt(1 - e * e);
                const x = -c + a * Math.cos(angle);
                const z = b * Math.sin(angle);
                
                pos.push(x, (Math.random() - 0.5) * 12, z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            return new THREE.Points(geo, new THREE.PointsMaterial({ color: colorHex, size: size, sizeAttenuation: false, transparent: true, opacity: opacity }));
        };
        asteroidBelt.add(createBeltPoints(2000, 210, 80, 0.01, 0.10, 2.0, 0xdcd2c8, 0.6));
        kuiperBelt.add(createBeltPoints(3000, 850, 400, 0.05, 0.20, 1.5, 0xb4d2f0, 0.5));

        // --- CONSTELLATIONS ---
        const constellationGroup = new THREE.Group();
        constellationGroup.visible = false;
        scene.add(constellationGroup);

        function getStarPos(raH, raM, decD, decM, dist) {
            // Conversion RA/Dec en coordonn√©es 3D
            const ra = (raH + raM/60) * 15 * Math.PI / 180;
            // Gestion du signe pour la d√©clinaison (ex: -8¬∞ 12')
            const sign = (decD < 0 || decM < 0) ? -1 : 1;
            const dec = sign * (Math.abs(decD) + Math.abs(decM)/60) * Math.PI / 180;
            
            // Dans cette sc√®ne, Y est "haut" (Nord C√©leste approximatif pour la visualisation)
            return new THREE.Vector3(
                dist * Math.cos(dec) * Math.cos(ra),
                dist * Math.sin(dec),
                dist * Math.cos(dec) * Math.sin(ra)
            );
        }

        const constellationsData = [
            {   name: "Grande Ourse",
                stars: [{h:11,m:3,d:61,mi:45}, {h:11,m:1,d:56,mi:22}, {h:11,m:53,d:53,mi:41}, {h:12,m:15,d:57,mi:1}, {h:12,m:54,d:55,mi:57}, {h:13,m:23,d:54,mi:55}, {h:13,m:47,d:49,mi:18}],
                connections: [[0,1], [1,2], [2,3], [3,0], [3,4], [4,5], [5,6]] },
            {   name: "Cassiop√©e",
                stars: [{h:0,m:9,d:59,mi:8}, {h:0,m:40,d:56,mi:32}, {h:0,m:56,d:60,mi:43}, {h:1,m:25,d:60,mi:14}, {h:1,m:54,d:63,mi:40}],
                connections: [[0,1], [1,2], [2,3], [3,4]] },
            {   name: "Orion",
                stars: [{h:5,m:55,d:7,mi:24}, {h:5,m:14,d:-8,mi:12}, {h:5,m:25,d:6,mi:20}, {h:5,m:47,d:-9,mi:40}, {h:5,m:40,d:-1,mi:56}, {h:5,m:36,d:-1,mi:12}, {h:5,m:32,d:0,mi:-17}],
                connections: [[0,2], [2,6], [6,5], [5,4], [4,0], [4,3], [6,1], [3,1]] }
        ];

        const rConst = 85000; // Juste √† l'int√©rieur du fond √©toil√©
        const lineMat = new THREE.LineBasicMaterial({ color: 0x4da8da, transparent: true, opacity: 0.5 });
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 600, sizeAttenuation: true, transparent: true });

        const allStarsGeo = new THREE.BufferGeometry();
        const allStarsPos = [];

        constellationsData.forEach(c => {
            const starVecs = c.stars.map(s => getStarPos(s.h, s.m, s.d, s.mi, rConst));
            
            // Ajout des √©toiles brillantes aux sommets
            starVecs.forEach(v => allStarsPos.push(v.x, v.y, v.z));

            // Cr√©ation des lignes
            const points = [];
            c.connections.forEach(pair => {
                points.push(starVecs[pair[0]]);
                points.push(starVecs[pair[1]]);
            });
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.LineSegments(lineGeo, lineMat);
            constellationGroup.add(line);
        });

        allStarsGeo.setAttribute('position', new THREE.Float32BufferAttribute(allStarsPos, 3));
        constellationGroup.add(new THREE.Points(allStarsGeo, starMat));

        document.getElementById('toggle-constellations').addEventListener('change', e => {
            constellationGroup.visible = e.target.checked;
        });

        // --- GESTION DE LA TRANSITION GALACTIQUE ---
        let currentGalaxyOpacity = 0;
        let targetGalaxyOpacity = 0;

        const galaxyBtn = document.getElementById('galaxy-btn');
        galaxyBtn.addEventListener('click', () => {
            targetGalaxyOpacity = (targetGalaxyOpacity === 0) ? 1 : 0;
            galaxyBtn.innerText = (targetGalaxyOpacity === 1) ? "üåå Masquer la Galaxie" : "üåå R√©v√©ler la Galaxie";
        });

        const toggleUiBtn = document.getElementById('toggle-ui-btn');
        const uiContent = document.getElementById('ui-content');
        toggleUiBtn.addEventListener('click', () => {
            if (uiContent.style.display === 'none') {
                uiContent.style.display = 'block'; toggleUiBtn.innerText = "üëÅÔ∏è Masquer l'interface";
            } else {
                uiContent.style.display = 'none'; toggleUiBtn.innerText = "üëÅÔ∏è Afficher les contr√¥les";
            }
        });

        const dp = document.getElementById('date-picker');
        dp.value = simulatedDate.toISOString().split('T')[0]; // Utiliser .value pour √©viter les pbs de fuseau horaire
        dp.addEventListener('change', e => {
            const dateParts = e.target.value.split('-'); // "YYYY-MM-DD"
            simulatedDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], 12, 0, 0));
            planets.forEach(p => { p.history = []; }); // R√©initialiser les tra√Æn√©es lors du changement de date pour √©viter les artefacts
        });
        
        let speed = 1, isPaused = false;
        document.getElementById('speed-slider').addEventListener('input', e => { speed = parseFloat(e.target.value); document.getElementById('speed-display').innerText = speed + " j/sec"; });
        
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            const dist = camera.position.distanceTo(controls.target);
            const newDist = dist / 1.3;
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).addScaledVector(direction, newDist);
        });
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            const dist = camera.position.distanceTo(controls.target);
            const newDist = dist * 1.3;
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).addScaledVector(direction, Math.min(newDist, controls.maxDistance));
        });

        document.getElementById('pause-btn').addEventListener('click', e => { isPaused = !isPaused; e.target.innerText = isPaused ? "Reprendre" : "Mettre en pause"; });
        document.getElementById('toggle-ecliptic').addEventListener('change', e => eclipticGrid.visible = e.target.checked);
        document.getElementById('toggle-orbits').addEventListener('change', e => orbitesMeshes.forEach(o => o.visible = e.target.checked));
        document.getElementById('toggle-asteroids').addEventListener('change', e => asteroidBelt.visible = e.target.checked);
        document.getElementById('toggle-kuiper').addEventListener('change', e => kuiperBelt.visible = e.target.checked);
        document.getElementById('night-mode-btn').addEventListener('click', e => { const over = document.getElementById('red-overlay'); over.style.display = over.style.display === 'block' ? 'none' : 'block'; });

        const targetSelect = document.getElementById('target-select');
        planets.forEach((p, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.innerText = p.name;
            targetSelect.appendChild(opt);
            if (p.moons) p.moons.forEach((m, j) => {
                const optM = document.createElement('option');
                optM.value = `${i}-${j}`;
                optM.innerText = ` ‚Ü≥ ${m.name}`;
                targetSelect.appendChild(optM);
            });
        });

        let trackedBody = null;
        targetSelect.addEventListener('change', e => {
            const val = e.target.value;
            if (val === "-1") trackedBody = null; else if (val.includes('-')) { const p = val.split('-'); trackedBody = planets[p[0]].moons[p[1]]; } else trackedBody = planets[val];
            if(trackedBody) showInfo(trackedBody); else document.getElementById('info-panel').classList.remove('active');
        });

        document.getElementById('close-info').addEventListener('click', () => { document.getElementById('info-panel').classList.remove('active'); targetSelect.value = "-1"; trackedBody = null; });

        function showInfo(body) {
            document.getElementById('info-name').innerText = body.name; document.getElementById('info-name').style.color = body.color === 0xffffff ? '#4b90d1' : "#" + body.color.toString(16).padStart(6, '0');
            document.getElementById('info-type').innerText = body.info.type; document.getElementById('info-diam').innerText = body.info.diam;
            document.getElementById('info-mass').innerText = body.info.mass; document.getElementById('info-temp').innerText = body.info.temp;
            document.getElementById('info-panel').classList.add('active');
        }

        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); const tooltip = document.getElementById('tooltip'); let hoveredObj = null;

        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(cliquables);
            
            if (intersects.length > 0 && !document.getElementById('info-panel').classList.contains('active')) {
                hoveredObj = intersects[0].object.userData.ref;
                tooltip.style.opacity = 1; tooltip.style.left = (e.clientX + 15) + 'px'; tooltip.style.top = (e.clientY - 40) + 'px';
                document.getElementById('tt-name').innerText = hoveredObj.name; document.getElementById('tt-dist').innerText = hoveredObj.realDist || "-"; document.getElementById('tt-ecc').innerText = hoveredObj.e !== undefined ? hoveredObj.e : "-";
                
                const line3 = document.getElementById('tt-line3');
                if (hoveredObj.name !== "Terre" && hoveredObj.name !== "Lune" && hoveredObj.name !== "Soleil" && hoveredObj.groupRef) {
                    document.getElementById('tt-line-horizon').style.display = 'block'; document.getElementById('tt-line-horizon').innerHTML = hoveredObj.isVisibleLocal ? "üî≠ <span style='color:#aaddff;'>Visible dans le ciel</span>" : "‚õ∞Ô∏è <span style='color:#777777;'>Sous l'horizon</span>";
                    const posTerre = planets[3].groupRef.position; const posPlanete = hoveredObj.groupRef.position;
                    const vTerreSoleil = new THREE.Vector3(0,0,0).sub(posTerre).normalize(); const vTerrePlanete = posPlanete.clone().sub(posTerre).normalize();
                    const angleDeg = vTerreSoleil.angleTo(vTerrePlanete) * (180 / Math.PI);
                    line3.style.display = 'block';
                    if (hoveredObj.a > planets[3].a) { if (angleDeg > 170) line3.innerHTML = "‚ú® <span style='color:#ffcc00;'>En Opposition !</span>"; else line3.innerHTML = `Angle stellaire : ${Math.round(angleDeg)}¬∞`;
                    } else { const maxElong = (hoveredObj.name === "V√©nus") ? 45 : 25; if (angleDeg > maxElong) line3.innerHTML = "üåÖ <span style='color:#ffaa00;'>√âlongation maximale</span>"; else line3.innerHTML = `√âlongation : ${Math.round(angleDeg)}¬∞`; }
                } else { document.getElementById('tt-line-horizon').style.display = 'none'; line3.style.display = 'none'; }
                document.body.style.cursor = 'pointer';
            } else { tooltip.style.opacity = 0; document.body.style.cursor = 'default'; hoveredObj = null; }
        });

        window.addEventListener('click', e => {
            if (e.target.closest('#ui-container') || e.target.closest('#info-panel')) return;
            if (hoveredObj) { trackedBody = hoveredObj; showInfo(trackedBody); const ud = raycaster.intersectObjects(cliquables)[0].object.userData; targetSelect.value = ud.isMoon ? `${ud.id}-${ud.moonId}` : ud.id;
            } else { trackedBody = null; document.getElementById('info-panel').classList.remove('active'); targetSelect.value = "-1"; }
        });

        const vecCible = new THREE.Vector3();
        const vecOrigin = new THREE.Vector3(0, 0, 0); // Vecteur r√©utilisable pour l'origine
        
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) { simulatedDate.setTime(simulatedDate.getTime() + (speed * 86400000 / 60)); }
            document.getElementById('date-display').innerText = simulatedDate.toLocaleDateString('fr-FR');
            
            const daysSinceJ2000 = (simulatedDate - J2000) / 86400000;
            const gmst = 280.46061837 + 360.98564736629 * daysSinceJ2000;
            const lstRad = ((gmst + obsLon) % 360) * Math.PI / 180;
            let posTerre = new THREE.Vector3();

            planets.forEach((p, i) => {
                if (i > 0) {
                    const pos = getKeplerPosition(p.a, p.e, p.period, p.baseAngle, p.omega, daysSinceJ2000, p.i, p.node);
                    p.groupRef.position.set(pos.x, pos.z, pos.y); p.meshRef.rotation.y += 0.01; if (i === 3) posTerre.set(pos.x, pos.z, pos.y); 
                    
                    // Mise √† jour de l'historique et de la tra√Æn√©e
                    if (!isPaused) {
                        p.history.push(new THREE.Vector3(pos.x, pos.z, pos.y));
                        if (p.history.length > 200) p.history.shift();
                        p.trailGeometry.setFromPoints(p.history);
                    }

                    if (p.moons) { p.moons.forEach(m => { let M = m.baseAngle + (daysSinceJ2000 / m.period) * Math.PI * 2; m.meshRef.position.set(Math.cos(M)*m.dist, 0, Math.sin(M)*m.dist); }); }
                } else { p.meshRef.rotation.y += 0.002; }
            });

            planets.forEach((p, i) => {
                if (i !== 3 && p.groupRef) {
                    let geoVec = p.groupRef.position.clone().sub(posTerre); let lambda = Math.atan2(geoVec.z, geoVec.x); 
                    let eps = 23.44 * Math.PI / 180; let dec = Math.asin(Math.sin(lambda) * Math.sin(eps)); let ra = Math.atan2(Math.sin(lambda) * Math.cos(eps), Math.cos(lambda));
                    let ha = lstRad - ra; let sinAlt = Math.sin(obsLat) * Math.sin(dec) + Math.cos(obsLat) * Math.cos(dec) * Math.cos(ha);
                    p.isVisibleLocal = sinAlt > 0;
                }
            });

            asteroidBelt.rotation.y += 0.0005; 
            kuiperBelt.rotation.y += 0.0002; 

            // --- ANIMATION CONSTELLATIONS (Pulsation) ---
            if (constellationGroup.visible) {
                const pulse = 0.4 + Math.sin(Date.now() * 0.0025) * 0.2; // Oscille doucement entre 0.2 et 0.6
                lineMat.opacity = pulse;
                starMat.opacity = pulse + 0.3; // Les √©toiles restent un peu plus brillantes que les lignes
            }

            // --- ANIMATION DE LA GALAXIE ---
            if (Math.abs(currentGalaxyOpacity - targetGalaxyOpacity) > 0.01) {
                currentGalaxyOpacity += (targetGalaxyOpacity - currentGalaxyOpacity) * 0.05;
                galaxyGroup.children.forEach(child => {
                    if (child.material && child.material.userData) {
                        child.material.opacity = currentGalaxyOpacity * child.material.userData.baseOpacity;
                    }
                });
            }

            if (trackedBody && trackedBody.meshRef) {
                trackedBody.meshRef.getWorldPosition(vecCible); controls.target.lerp(vecCible, 0.1);
            } else { controls.target.lerp(vecOrigin, 0.05); }

            controls.update(); renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>