<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exploration Lunaire 3D</title>
    <style>
        html,body{width:100%;height:100%;margin:0;padding:0;overflow:hidden;background:#020205;font-family:sans-serif;color:#fff;touch-action:none}
        #ui-container{position:absolute;top:10px;left:10px;background:rgba(10,15,30,.85);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);z-index:10;backdrop-filter:blur(4px);max-width:220px;}
        h1{margin:0 0 10px;font-size:1rem;color:#4da8da;text-transform:uppercase}
        .control-group{margin-bottom:10px;display:flex;flex-direction:column;gap:5px}
        button{background:#4da8da;color:#050510;border:none;padding:8px;border-radius:5px;cursor:pointer;font-weight:bold;width:100%; transition: 0.3s;}
        button:hover{background:#79c2ea}
        .info-box { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; font-size: 0.85rem; line-height: 1.4; border: 1px solid rgba(77,168,218,0.2); }
        .highlight { color: #4da8da; font-weight: bold; }
        canvas{display:block;width:100%;height:100%}
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>Exploration Lunaire</h1>
        <div class="control-group">
            <div class="info-box">
                <span class="highlight">Phase :</span> <span id="moon-phase">-</span><br>
                <span class="highlight">Distance :</span> 384 400 km<br>
                <span class="highlight">Rotation :</span> Synchrone<br>
                <span class="highlight">Lieu :</span> <span id="selected-sea">Aucun</span><br>
                <span class="highlight">Syzygie :</span> <span id="syzygy-status">Non</span>
            </div>
        </div>
        <div class="control-group">
            <label style="font-size: 0.8rem;">√âclairage Solaire (Phase) :</label>
            <input type="range" id="phase-slider" min="0" max="6.28" step="0.01" value="0">
            <button id="auto-align-btn" style="margin-top: 5px; background: #ffcc00; color: #050510;">‚ú® Auto-alignement</button>
        </div>
        <a href="index.html" style="text-decoration:none;"><button>üè† Retour Accueil</button></a>
    </div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 10000);
        camera.position.set(0, 20, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lumi√®re du Soleil (Directionnelle pour cr√©er des phases nettes)
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(100, 0, 0);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Lumi√®re cendr√©e (faible lumi√®re refl√©t√©e par la Terre)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
        scene.add(ambientLight);

        const textureLoader = new THREE.TextureLoader();
        const CDN_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/';

        // --- LA LUNE ---
        const moonGeo = new THREE.SphereGeometry(10, 64, 64);
        const moonMat = new THREE.MeshStandardMaterial({ 
            roughness: 1, 
            metalness: 0,
            bumpScale: 0.8 // Ajustez cette valeur pour accentuer ou r√©duire le relief
        });
        const moon = new THREE.Mesh(moonGeo, moonMat);
        moon.receiveShadow = true;
        scene.add(moon);

        textureLoader.load(CDN_URL + 'moon_1024.jpg', (tex) => {
            moonMat.map = tex;
            moonMat.bumpMap = tex; // Utilisation de la texture principale comme carte de relief
            moonMat.needsUpdate = true;
        });

        // --- MARQUEURS DES MERS LUNAIRES ---
        const lunarSeas = [
            { name: "Mer de la Tranquillit√©", lat: 8.5, lon: 31.4 },
            { name: "Mer de la S√©r√©nit√©", lat: 28.0, lon: 17.5 },
            { name: "Mer des Pluies", lat: 32.8, lon: -15.6 },
            { name: "Mer des Crises", lat: 17.0, lon: 59.1 },
            { name: "Oc√©an des Temp√™tes", lat: 18.4, lon: -57.4 },
            { name: "Mer de la F√©condit√©", lat: -7.8, lon: 51.3 },
            { name: "Mer du Nectar", lat: -15.2, lon: 35.5 },
            { name: "Mer des Nu√©es", lat: -19.1, lon: -15.0 }
        ];

        const markerGroup = new THREE.Group();
        scene.add(markerGroup);

        function latLonToVector3(lat, lon, radius) {
            const phi = lat * (Math.PI / 180);
            const theta = lon * (Math.PI / 180);
            return new THREE.Vector3(
                radius * Math.cos(phi) * Math.sin(theta),
                radius * Math.sin(phi),
                radius * Math.cos(phi) * Math.cos(theta)
            );
        }

        lunarSeas.forEach(sea => {
            const pos = latLonToVector3(sea.lat, sea.lon, 10.2); // L√©g√®rement au-dessus de la surface (radius=10)
            const markerGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.8 });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.copy(pos);
            marker.userData = sea;
            markerGroup.add(marker);
        });

        // --- INTERACTION (CLIC) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const selectedSeaText = document.getElementById('selected-sea');

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(markerGroup.children);
            if (intersects.length > 0) {
                selectedSeaText.innerText = intersects[0].object.userData.name;
            }
        });

        // --- LA TERRE (en arri√®re-plan) ---
        const earthGeo = new THREE.SphereGeometry(36, 64, 64);
        const earthMat = new THREE.MeshStandardMaterial({ roughness: 1 });
        const earth = new THREE.Mesh(earthGeo, earthMat);
        earth.position.set(-200, 0, -100); // Distance arbitraire pour le visuel
        scene.add(earth);

        textureLoader.load(CDN_URL + 'earth_atmos_2048.jpg', (tex) => {
            earthMat.map = tex;
            earthMat.needsUpdate = true;
        });

        // --- FOND √âTOIL√â ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) {
            const r = 2000;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 1})));

        // --- LOGIQUE DES PHASES ---
        const phaseSlider = document.getElementById('phase-slider');
        const phaseText = document.getElementById('moon-phase');
        const syzygyText = document.getElementById('syzygy-status');

        // --- AUTO-ALIGNEMENT ---
        document.getElementById('auto-align-btn').addEventListener('click', () => {
            const currentEarthAngle = (Date.now() * 0.0001) % (Math.PI * 2);
            const currentSunAngle = parseFloat(phaseSlider.value);
            
            const t1 = currentEarthAngle; // Cible : Nouvelle Lune (Conjonction)
            const t2 = (currentEarthAngle + Math.PI) % (Math.PI * 2); // Cible : Pleine Lune (Opposition)
            
            // On calcule la distance la plus courte vers l'un des deux points d'alignement
            const d1 = Math.min(Math.abs(currentSunAngle - t1), 2 * Math.PI - Math.abs(currentSunAngle - t1));
            const d2 = Math.min(Math.abs(currentSunAngle - t2), 2 * Math.PI - Math.abs(currentSunAngle - t2));
            
            phaseSlider.value = (d1 < d2 ? t1 : t2).toFixed(2);
        });

        function checkSyzygy(sunAngle, earthAngle) {
            // Calcul de la diff√©rence d'angle entre le Soleil et la Terre par rapport √† la Lune
            const diff = Math.abs(sunAngle - earthAngle) % Math.PI;
            const threshold = 0.1; // Tol√©rance d'alignement (environ 5.7 degr√©s)

            if (diff < threshold) {
                syzygyText.innerText = "Oui (Conjonction)";
                syzygyText.style.color = "#ffcc00";
            } else if (diff > Math.PI - threshold) {
                syzygyText.innerText = "Oui (Opposition)";
                syzygyText.style.color = "#ffcc00";
            } else {
                syzygyText.innerText = "Non";
                syzygyText.style.color = "#fff";
            }
        }

        function updatePhaseText(angle) {
            const normAngle = (angle % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
            if (normAngle < 0.4 || normAngle > 5.9) phaseText.innerText = "Nouvelle Lune";
            else if (normAngle < 1.2) phaseText.innerText = "Premier Croissant";
            else if (normAngle < 1.9) phaseText.innerText = "Premier Quartier";
            else if (normAngle < 2.7) phaseText.innerText = "Gibbeuse Croissante";
            else if (normAngle < 3.5) phaseText.innerText = "Pleine Lune";
            else if (normAngle < 4.3) phaseText.innerText = "Gibbeuse D√©croissante";
            else if (normAngle < 5.1) phaseText.innerText = "Dernier Quartier";
            else phaseText.innerText = "Dernier Croissant";
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Position du soleil bas√©e sur le slider
            const angle = parseFloat(phaseSlider.value);
            sunLight.position.set(Math.cos(angle) * 100, 0, Math.sin(angle) * 100);
            updatePhaseText(angle);

            // Rotation synchrone (la Lune pr√©sente toujours la m√™me face √† la Terre)
            // Ici, on fait tourner la Terre autour de la Lune pour le visuel
            const earthAngle = Date.now() * 0.0001;
            earth.position.x = Math.cos(earthAngle) * 300;
            earth.position.z = Math.sin(earthAngle) * 300;
            earth.rotation.y += 0.002;

            // V√©rification de l'alignement Terre-Lune-Soleil
            checkSyzygy(angle, earthAngle);

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(markerGroup.children);
            renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
        });

        animate();
    </script>
</body>
</html>